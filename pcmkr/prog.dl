import group

typedef id_t = u64

// ======================= Resource & Node =======================

typedef rsc_variant_t = Primitive
                    | Group
                    | Clone
                    | Bundle

input relation Rsc(id: id_t, variant: rsc_variant_t)
primary key(x) (x.id)

input relation Node(id: id_t)
primary key(x) (x.id)


// ======================= Location & Colocation =======================

input relation LocationConstraint (id: id_t, rsc_id: id_t, node_id: id_t, score: float)
input relation ColocationConstraint (id: id_t, rsc_id: id_t, with_rsc: id_t)

relation Location (rsc_id: id_t, node_id: id_t)
relation Colocation (rsc_id: id_t, with_rsc: id_t, node_id: id_t)
output relation TotalLocation (rsc_id: id_t, node_id: id_t)


Location (rsc_id, target_node) :- 
	LocationConstraint (.rsc_id = rsc_id, .node_id = node_id, .score = score),
	var rsc_group = (node_id, score).group_by(rsc_id),
	(var target_node, var max_score) = rsc_group.arg_max(|node_score| node_score.1).

Location (rsc_id, target_node) :- 
	Rsc(.id=rsc_id), 
	Node(target_node),
	not LocationConstraint (_, rsc_id, _, _).

Colocation (rsc_id, with_rsc, node_id) :-
	ColocationConstraint (.rsc_id = rsc_id, .with_rsc = with_rsc),
	Location(with_rsc, node_id).

TotalLocation (rsc_id, node_id) :-
	Colocation (.rsc_id = rsc_id, .node_id = node_id).

TotalLocation (rsc_id, node_id) :-
	Location (.rsc_id = rsc_id, .node_id = node_id),
	not Colocation (rsc_id, _, _).


// ======================= Ordering (Actions graph) =======================

typedef uint_t = u64
typedef flag_t = bit<64>
typedef task_t = 
    Start   | Started  |
    Stop    | Stopped  |
    Promote | Promoted |
    Demote  | Demoted  |
    Monitor

// ==== FLAGS ====
function pseudo_flag(): flag_t       = 'h00001
function runnable_flag(): flag_t     = 'h00002
function optional_flag(): flag_t     = 'h00004
function print_always_flag(): flag_t = 'h00008
function requires_any_flag(): flag_t = 'h01000

// ==== Relations ====
/*
    Actions data needed for ordering (nodes in action graph)
*/
input relation Action(
    id: id_t, 
    rsc_id: Option<id_t>, 
    task: task_t,
    interval: uint_t,
    node_id: Option<id_t>, 
    flags: flag_t,
    deps_num: uint_t, // required number of runnable before actions
)
primary key(x) (x.id)

/*
    Actions ordering data (edges in anction graph)
*/
input relation ActionsGraph(first_id: id_t, then_id: id_t, order_type: flag_t)

// Intermediate relations
relation RunnableActionsBefore(id: id_t, runnable_dependencies_num: uint_t, before: Vec<id_t>)

// Output relations
output relation RunnableActions(id: id_t)


// ==== Rules ====
RunnableActionsBefore(then_id, num, lst) :-
    ActionsGraph(first_id, then_id, _),
    RunnableActions(first_id),
    var lst = first_id.group_by(then_id).to_vec(),
    var num = len(lst).

RunnableActions(id) :- 
    Action(.id=id, .flags=flags),
    is_set(flags, runnable_flag()).

RunnableActions(then_id) :-
    ActionsGraph(.first_id=first_id, .then_id=then_id),
    RunnableActionsBefore(then_id, num, _),
    Action(.id=then_id, .deps_num=deps_num),
    (num >= deps_num).

function is_set(bit_vec: flag_t, flag: flag_t): bool {
    (~bit_vec & flag) == 0
}

// ========== TMP ==========

output relation PseudoAction(id: id_t)

PseudoAction(action.id) :- action in Action(.flags=flags), is_set(flags, pseudo_flag()).