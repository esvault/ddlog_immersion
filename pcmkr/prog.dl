import group

typedef id_t = u64

// ======================= Resource & Node =======================

typedef rsc_variant_t = Primitive
                    | Group
                    | Clone
                    | Bundle

input relation Rsc(id: id_t, variant: rsc_variant_t)
primary key(x) (x.id)

input relation Node(id: id_t)
primary key(x) (x.id)


// ======================= Location & Colocation =======================

input relation LocationConstraint (id: id_t, rsc_id: id_t, node_id: id_t, score: float)
input relation ColocationConstraint (id: id_t, rsc_id: id_t, with_rsc: id_t)

relation Location (rsc_id: id_t, node_id: id_t)
relation Colocation (rsc_id: id_t, with_rsc: id_t, node_id: id_t)
output relation TotalLocation (rsc_id: id_t, node_id: id_t)


Location (rsc_id, target_node) :- 
	LocationConstraint (.rsc_id = rsc_id, .node_id = node_id, .score = score),
	var rsc_group = (node_id, score).group_by(rsc_id),
	(var target_node, var max_score) = rsc_group.arg_max(|node_score| node_score.1).

Location (rsc_id, target_node) :- 
	Rsc(.id=rsc_id), 
	Node(target_node),
	not LocationConstraint (_, rsc_id, _, _).

Colocation (rsc_id, with_rsc, node_id) :-
	ColocationConstraint (.rsc_id = rsc_id, .with_rsc = with_rsc),
	Location(with_rsc, node_id).

TotalLocation (rsc_id, node_id) :-
	Colocation (.rsc_id = rsc_id, .node_id = node_id).

TotalLocation (rsc_id, node_id) :-
	Location (.rsc_id = rsc_id, .node_id = node_id),
	not Colocation (rsc_id, _, _).


// ======================= Ordering (Actions graph) =======================

typedef uint_t = u64
typedef flag_t = bit<64>
typedef task_t = 
    Start   | Started  |
    Stop    | Stopped  |
    Promote | Promoted |
    Demote  | Demoted  |
    Monitor

// ==== FLAGS ====
function pseudo_flag(): flag_t       = 'h00001
function runnable_flag(): flag_t     = 'h00002
function optional_flag(): flag_t     = 'h00004
function print_always_flag(): flag_t = 'h00008
function requires_any_flag(): flag_t = 'h01000

// ==== Relations ====
/*
    Actions data needed for ordering (nodes in action graph)
*/
input relation &Action(
    id: id_t, 
    rsc_id: Option<id_t>, 
    task: task_t,
    interval: uint_t,
    node_id: Option<id_t>, 
    flags: flag_t,
    deps_num: uint_t, // required number of runnable before actions
)
primary key(x) (x.id)

/*
    Actions ordering data (edges in anction graph)
*/
input relation ActionsGraph(first_id: id_t, then_id: id_t, order_type: flag_t)

// Intermediate relations
relation RunnableActionsBefore(id: id_t, runnable_dependencies_num: uint_t, before: Vec<id_t>)
relation RunnableActions(action: Ref<Action>)
relation UnrunnableActions(action: Ref<Action>)
relation OptionalActions(action: Ref<Action>)

relation PrimitiveActions(action: Ref<Action>)
relation CloneActions(action: Ref<Action>)


// Output relations
output relation EdgesToDelete(from: id_t, to: id_t)
output relation EdgesToInsert(from: id_t, to: id_t)

// ==== Rules ====
RunnableActionsBefore(then_id, num, lst) :-
    ActionsGraph(first_id, then_id, _),
    action in &Action(.id=first_id),
    is_runnable(action),
    var lst = first_id.group_by(then_id).to_vec(),
    var num = len(lst).

RunnableActions(action) :- 
    action in &Action(.id=id, .flags=flags),
    not UnrunnableActions(action).

UnrunnableActions(action) :-
    action in &Action(.id=id, .flags=flags),
    not is_set(flags, runnable_flag()).

OptionalActions(action) :-
    action in &Action(.id=id, .flags=flags),
    is_set(flags, optional_flag()).

RunnableActions(action) :-
    ActionsGraph(.first_id=first_id, .then_id=then_id),
    RunnableActionsBefore(then_id, num, _),
    action in &Action(.id=then_id, .deps_num=deps_num),
    (num >= deps_num).


EdgesToDelete(first_id, then_id),
EdgesToInsert(find_id, then_id) :-
    ActionsGraph(.first_id=first_id, .then_id=then_id),
    CloneActions(&Action{.id=first_id, .task=Stop}),
    CloneActions(&Action{.id= then_id, .task=Stop}),
    ActionsGraph(first_id, find_id, _), &Action(.id=find_id, .task=Stopped).

EdgesToDelete(first_id, then_id),
EdgesToInsert(find_id, then_id) :-
    ActionsGraph(.first_id=first_id, .then_id=then_id),
    CloneActions(&Action{.id=first_id, .task=Start}),
    CloneActions(&Action{.id= then_id, .task=Start}),
    ActionsGraph(first_id, find_id, _), &Action(.id=find_id, .task=Started).

  
CloneActions(action) :-
    action in &Action(),
    action.node_id == None,
    var rsc_id = unwrap_or(action.rsc_id, -1),
    Rsc(.id=rsc_id, .variant=Clone).

PrimitiveActions(action) :-
    action in &Action(),
    var rsc_id = unwrap_or(action.rsc_id, -1),
    Rsc(.id=rsc_id, .variant=Primitive).

function is_set(bit_vec: flag_t, flag: flag_t): bool {
    (~bit_vec & flag) == 0
}

function is_pseudo(action: Ref<Action>): bool {
    is_set(action.flags, pseudo_flag())
}

function is_runnable(action: Ref<Action>): bool {
    is_set(action.flags, runnable_flag())
}

function is_optional(action: Ref<Action>): bool {
    is_set(action.flags, optional_flag())
}

function is_print_always(action: Ref<Action>): bool {
    is_set(action.flags, print_always_flag())
}
