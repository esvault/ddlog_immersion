import group

typedef uint_t = u64
typedef id_t = u64
typedef flag_t = bit<64>

// ======================= Resource & Node =======================

typedef rsc_variant_t = Primitive
                    | Group
                    | Clone
                    | Bundle

input relation Rsc(id: id_t, variant: rsc_variant_t)
primary key(x) (x.id)

input relation Node(id: id_t)
primary key(x) (x.id)


// ======================= Location & Colocation =======================

input relation LocationConstraint (id: id_t, rsc_id: id_t, node_id: id_t, score: float)
input relation ColocationConstraint (id: id_t, rsc_id: id_t, with_rsc: id_t)

relation Location (rsc_id: id_t, node_id: id_t)
relation Colocation (rsc_id: id_t, with_rsc: id_t, node_id: id_t)
output relation TotalLocation (rsc_id: id_t, node_id: id_t)


Location (rsc_id, target_node) :- 
	LocationConstraint (.rsc_id = rsc_id, .node_id = node_id, .score = score),
	var rsc_group = (node_id, score).group_by(rsc_id),
	(var target_node, var max_score) = rsc_group.arg_max(|node_score| node_score.1).

Location (rsc_id, target_node) :- 
	Rsc(.id=rsc_id), 
	Node(target_node),
	not LocationConstraint (_, rsc_id, _, _).

Colocation (rsc_id, with_rsc, node_id) :-
	ColocationConstraint (.rsc_id = rsc_id, .with_rsc = with_rsc),
	Location(with_rsc, node_id).

TotalLocation (rsc_id, node_id) :-
	Colocation (.rsc_id = rsc_id, .node_id = node_id).

TotalLocation (rsc_id, node_id) :-
	Location (.rsc_id = rsc_id, .node_id = node_id),
	not Colocation (rsc_id, _, _).


// ======================= Ordering (Actions graph) =======================

typedef task_t = 
    Start   | Started  |
    Stop    | Stopped  |
    Promote | Promoted |
    Demote  | Demoted  |
    Monitor

input relation Action(
    id: id_t, 
    rsc_id: Option<id_t>, 
    task: task_t,
    interval: uint_t,
    node_id: Option<id_t>, 
    flags: flag_t,
    deps_num: uint_t, // required number of runnable before actions
)
primary key(x) (x.id)

input relation ActionsGraph(first_id: id_t, then_id: id_t, order_type: flag_t)


output relation RunnableActionsBefore(id: id_t, runnable_dependencies_num: uint_t)
output relation RunnableActions(id: id_t)

// TODO: Как понять, сколько из actions_before уже в RunnableActions
RunnableActionsBefore(then_id, num) :-
    ActionsGraph(first_id, then_id, _),
    var num = first_id.group_by(then_id).count(|x| true). // Подсчитывается количество actions_before, а не runnable


RunnableActions(then_id) :-
    ActionsGraph(.first_id=first_id, .then_id=then_id),
    RunnableActionsBefore(then_id, num),
    Action(.id=then_id, .deps_num=deps_num),
    (num >= deps_num).
