typedef INT = bit<64>
typedef FLAG = bit<32>

typedef Nullable<'A> = NULL
		     | Val {value : 'A}

typedef pe_resource_t = Resource {
	id: INT
}

typedef pe_node_t = Node {
	id: INT
}

typedef pe_action_t = Action {
	id: INT,
	task: string,
	rsc: Nullable<pe_resource_t>,
	node: Nullable<pe_node_t>,
	flags: FLAG
}

typedef wrapper_t = Wrapper {
	order_type: FLAG,
	action: pe_action_t
}

typedef pe_order_t = Order {
	id: INT,
	flags: FLAG,
	
	l_rsc_id: INT,
	l_action_id: INT,
	l_task: string,
	
	r_rsc_id: INT,
	r_action_id: INT,
	r_task: string
}

function is_set(flags: FLAG, flag: FLAG): bool {
	(flags & flag) != 0
}

function pe_action_optional(): FLAG { 32'h00004 }

function pe_order_none(): FLAG { 0 }
function pe_order_same_node(): FLAG { 32768 }
function pe_order_then_cancels_first(): FLAG { 33554432 }
function pe_order_implies_then_on_node(): FLAG { 32'h400 }


//======================= Отношения для основных сущностей pacemaker ========================

input relation ResourseRel(id: INT)
primary key(x) (x.id)

input relation NodeRel(id: INT)
primary key(x) (x.id)

input relation ActionRel(id: INT, action: pe_action_t, tmp: FLAG)
primary key(x) (x.action.id)



//=================== Отношения для списков actions_before, actions_after ===================

input relation InputActionsBefore(action: pe_action_t, wrapper: wrapper_t)
primary key(x) (x.action.id, x.wrapper.action.id)

input relation InputActionsAfter(action: pe_action_t, wrapper: wrapper_t)
primary key(x) (x.action.id, x.wrapper.action.id)

output relation ActionsBefore(action: pe_action_t, wrapper: wrapper_t)
output relation ActionsAfter(action: pe_action_t, wrapper: wrapper_t)

ActionsBefore(action, wrapper) :- InputActionsBefore(action, wrapper).
ActionsAfter(action, wrapper) :- InputActionsAfter(action, wrapper).



//=================== Отношения для списков actions_before, actions_after ===================

input relation InputActionsBeforeLst(action_id: INT, lst: Vec<wrapper_t>)
primary key(x) (x.action_id)

input relation InputActionsAfterLst(action_id: INT, lst: Vec<wrapper_t>)
primary key(x) (x.action_id)

output relation ActionsBeforeLst(action_id: INT, lst: Vec<wrapper_t>)
output relation ActionsAfterLst(action_id: INT, lst: Vec<wrapper_t>)

ActionsBeforeLst(id, lst) :- InputActionsBeforeLst(id, lst).
ActionsAfterLst(id, lst) :- InputActionsAfterLst(id, lst).



//================================== Отношение для Wrapper ==================================


output relation ActionWrapper(action_id: INT, ordering_type: FLAG)

// ActionWrapper(id, 0) :- ActionRel(id, _, _, _, _).



//================================== Отношения для флагов ===================================

output relation ActionRequiresAny(action: pe_action_t)
ActionRequiresAny(action) :- ActionRel(_,action,_), is_set(action.flags, 32'h01000).

			 
output relation ActionRunnable(action: pe_action_t)
ActionRunnable(action) :- ActionRel(_,action,_), is_set(action.flags, 32'h00002).


output relation ActionOptional(action: pe_action_t)
ActionOptional(action) :- ActionRel(_,action,_), is_set(action.flags, 32'h00004).

ActionOptional(first.action) :- OrderThenCancelsFirst(then, first),
								ActionRel(_,then,_),
								not is_set(then.flags, pe_action_optional()).
						 		
						 		

		      
output relation ActionPseudo(action: pe_action_t)
ActionPseudo(action) :- ActionRel(_,action,_), is_set(action.flags, 32'h00001).

		      
		      
//================================== Отношение для Order ====================================

input relation OrderRel(
	id: INT,
	flags: FLAG,
	
	l_rsc_id: INT,
	l_action_id: INT,
	l_task: string,
	
	r_rsc_id: INT,
	r_action_id: INT,
	r_task: string
)

output relation OrderNone(action: pe_action_t, wrapper: wrapper_t)
OrderNone(action, wrapper) :- ActionsBefore(action, wrapper@Wrapper{.order_type=t}),
							  t == pe_order_none(). 
							  
OrderNone(action, wrapper) :- ActionsBefore(action, wrapper@Wrapper{.order_type=t}),
							  is_set(action.flags, pe_order_same_node()).


output relation OrderThenCancelsFirst(action: pe_action_t, wrapper: wrapper_t)							  						  
OrderThenCancelsFirst(action, wrapper) :- ActionsBefore(action, wrapper@Wrapper{.order_type=t}),
							 		 	  is_set(t, pe_order_then_cancels_first()).
							 		 
							 		 
output relation OrderImpliesThenOnNode(action: pe_action_t, wrapper: wrapper_t)
OrderImpliesThenOnNode(action, wrapper):- ActionsBefore(action, wrapper@Wrapper{.order_type=t}),
										  is_set(t, pe_order_implies_then_on_node()).

							 		
